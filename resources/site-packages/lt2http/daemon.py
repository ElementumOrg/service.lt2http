import os
import errno
import stat
import time
import shutil
import socket
import filecmp
import threading
import six

from kodi_six import xbmc, xbmcgui
from six.moves import urllib_request
from kodi_six.utils import py2_decode

from lt2http.logger import log
from lt2http.osarch import PLATFORM, get_platform
from lt2http.config import LT2HTTP_HOST
from lt2http.addon import ADDON, ADDON_ID, ADDON_PATH, ADDON_VERSION
from lt2http.util import (notify, dialog_ok, system_information, toUtf8,
                          getLocalizedString, getWindowsShortPath, translatePath,
                          download_github_folder, read_current_version, write_current_version,
                          download_current_version)

try:
    import subprocess
    hasSubprocess = True
    if not PLATFORM["fork"]:
        hasSubprocess = False
except:
    hasSubprocess = False

binary_platform = {}
repo = "ElementumOrg/lt2http-binaries"

def ensure_exec_perms(file_):
    st = os.stat(file_)
    os.chmod(file_, st.st_mode | stat.S_IEXEC)
    return file_

def android_get_current_appid():
    with open("/proc/%d/cmdline" % os.getpid()) as fp:
        return fp.read().rstrip("\0")

def get_lt2http_checksum(path):
    if not os.path.exists(path):
        return ""

    stats = os.stat(path)
    if stats.st_size < 40:
        return ""

    try:
        with open(path) as fp:
            fp.seek(-40, os.SEEK_END)  # we put a sha1 there
            return fp.read()
    except Exception:
        return ""


def get_lt2http_binary():
    global binary_platform
    binary_platform = get_platform()

    binary = "lt2http" + (binary_platform["os"] == "windows" and ".exe" or "")
    binary_dir = os.path.join(ADDON_PATH, "resources", "bin", "%(os)s-%(arch)s" % binary_platform)

    if binary_platform["os"] == "android":
        log.info("Detected binary folder: %s" % binary_dir)
        binary_dir_legacy = binary_dir.replace("/storage/emulated/0", "/storage/emulated/legacy")
        if os.path.exists(binary_dir_legacy):
            binary_dir = binary_dir_legacy
            log.info("Using changed binary folder for Android: %s" % binary_dir)

        app_id = android_get_current_appid()
        xbmc_data_path = os.path.join("/data", "data", app_id)
        if not os.path.exists(xbmc_data_path):
            log.info("%s path does not exist, so using %s as xbmc_data_path" % (xbmc_data_path, translatePath("special://xbmcbin/")))
            xbmc_data_path = translatePath("special://xbmcbin/")

        if not os.path.exists(xbmc_data_path):
            log.info("%s path does not exist, so using %s as xbmc_data_path" % (xbmc_data_path, translatePath("special://masterprofile/")))
            xbmc_data_path = translatePath("special://masterprofile/")

        dest_binary_dir = os.path.join(xbmc_data_path, "files", ADDON_ID, "bin", "%(os)s-%(arch)s" % binary_platform)
    else:
        try:
            dest_binary_dir = os.path.join(translatePath(ADDON.getAddonInfo("profile")).decode('utf-8'), "bin", "%(os)s-%(arch)s" % binary_platform)
        except Exception:
            dest_binary_dir = os.path.join(translatePath(ADDON.getAddonInfo("profile")), "bin", "%(os)s-%(arch)s" % binary_platform)

    binary_path = os.path.join(binary_dir, binary)
    dest_binary_path = os.path.join(dest_binary_dir, binary)
    installed_version = read_current_version(binary_dir)

    log.info("Binary detection. Source: %s, Destination: %s" % (binary_path, dest_binary_path))

    if not os.path.exists(binary_path) or not installed_version or ADDON_VERSION > installed_version:
        try:
            os.makedirs(binary_dir)
        except OSError as e:
            if e.errno != errno.EEXIST:
                raise

        notify("LOCALIZE[30658];;" + "%(os)s-%(arch)s" % binary_platform)
        if not download_github_folder(repo, "%(os)s-%(arch)s" % binary_platform, binary_dir):
            log.error("Unable to download binary to destination path")
            system_information()
            return False, False
        version = download_current_version(repo)
        write_current_version(binary_dir, version)

    if not os.path.exists(binary_path):
        # notify((getLocalizedString(30103) + " %(os)s_%(arch)s" % PLATFORM), time=7000)
        dialog_ok("LOCALIZE[30347];;" + "%(os)s-%(arch)s" % binary_platform)
        system_information()
        try:
            log.info("Source directory (%s):\n%s" % (binary_dir, os.listdir(os.path.join(binary_dir, ".."))))
            log.info("Destination directory (%s):\n%s" % (dest_binary_dir, os.listdir(os.path.join(dest_binary_dir, ".."))))
        except Exception:
            pass
        return False, False

    if os.path.isdir(dest_binary_path):
        log.warning("Destination path is a directory, expected previous binary file, removing...")
        try:
            shutil.rmtree(dest_binary_path)
        except Exception as e:
            log.error("Unable to remove destination path for update: %s" % e)
            system_information()
            return False, False

    if not os.path.exists(dest_binary_path) or not os.path.exists(binary_path) or get_lt2http_checksum(dest_binary_path) != get_lt2http_checksum(binary_path) or not filecmp.cmp(dest_binary_path, binary_path, shallow=True):
        log.info("Updating lt2http daemon...")
        try:
            os.makedirs(dest_binary_dir)
        except OSError:
            pass
        try:
            shutil.rmtree(dest_binary_dir)
        except Exception as e:
            log.error("Unable to remove destination path for update: %s" % e)
            system_information()
            pass
        try:
            shutil.copytree(binary_dir, dest_binary_dir)
        except Exception as e:
            log.error("Unable to copy to destination path for update: %s" % e)
            system_information()
            return False, False

    # Clean stale files in the directory, as this can cause headaches on
    # Android when they are unreachable
    dest_files = set(os.listdir(dest_binary_dir))
    orig_files = set(os.listdir(binary_dir))
    log.info("Deleting stale files %s" % (dest_files - orig_files))
    for file_ in (dest_files - orig_files):
        path = os.path.join(dest_binary_dir, file_)
        if os.path.isdir(path):
            shutil.rmtree(path)
        else:
            os.remove(path)

    log.info("Binary detection: [ Source: %s, Destination: %s ]" % (binary_path, dest_binary_path))
    return dest_binary_dir, ensure_exec_perms(dest_binary_path)

def clear_fd_inherit_flags():
    # Ensure the spawned lt2http binary doesn't inherit open files from Kodi
    # which can break things like addon updates. [WINDOWS ONLY]
    try:
        from ctypes import windll

        HANDLE_RANGE = six.moves.xrange(0, 65536)
        HANDLE_FLAG_INHERIT = 1
        FILE_TYPE_DISK = 1

        for hd in HANDLE_RANGE:
            if windll.kernel32.GetFileType(hd) == FILE_TYPE_DISK:
                if not windll.kernel32.SetHandleInformation(hd, HANDLE_FLAG_INHERIT, 0):
                    log.error("Error clearing inherit flag, disk file handle %x" % hd)
    except:
        pass

def jsonrpc_enabled(notify=False):
    try:
        s = socket.socket()
        s.connect(('127.0.0.1', 9090))
        s.close()
        log.info("Kodi's JSON-RPC service is available, starting up...")
        del s
        return True
    except Exception as e:
        log.error(repr(e))
        if notify:
            xbmc.executebuiltin("ActivateWindow(ServiceSettings)")
            dialog = xbmcgui.Dialog()
            dialog.ok("Lt2Http", getLocalizedString(30199))
    return False

def start_lt2http(**kwargs):
    jsonrpc_failures = 0
    while jsonrpc_enabled() is False:
        jsonrpc_failures += 1
        log.warning("Unable to connect to Kodi's JSON-RPC service, retrying...")
        if jsonrpc_failures > 1:
            time.sleep(5)
            if not jsonrpc_enabled(notify=True):
                log.error("Unable to reach Kodi's JSON-RPC service, aborting...")
                return False
            else:
                break
        time.sleep(3)

    lt2http_dir, lt2http_binary = get_lt2http_binary()

    log.info("Binary dir: %s, item: %s " % (lt2http_dir, lt2http_binary))
    if lt2http_dir is False or lt2http_binary is False:
        return False

    lockfile = os.path.join(ADDON_PATH, ".lockfile")
    if os.path.exists(lockfile):
        log.warning("Existing process found from lockfile, killing...")
        try:
            with open(lockfile) as lf:
                pid = int(lf.read().rstrip(" \t\r\n\0"))
            os.kill(pid, 9)
        except OSError as e:
            if e.errno != 3:
                # Ignore:   OSError: [Errno 3] No such process
                log.error(repr(e))
        except Exception as e:
            log.error(repr(e))

        if binary_platform["os"] == "windows":
            try:
                library_lockfile = os.path.join(py2_decode(translatePath(ADDON.getAddonInfo("profile"))), "library.db.lock")
                log.warning("Removing library.db.lock file at %s ..." % library_lockfile)
                os.remove(library_lockfile)
            except Exception as e:
                log.error(repr(e))

    SW_HIDE = 0
    STARTF_USESHOWWINDOW = 1

    args = [lt2http_binary]
    kwargs["cwd"] = lt2http_dir

    if binary_platform["os"] == "windows":
        args[0] = getWindowsShortPath(lt2http_binary)
        kwargs["cwd"] = getWindowsShortPath(lt2http_dir)
        si = subprocess.STARTUPINFO()
        si.dwFlags = STARTF_USESHOWWINDOW
        si.wShowWindow = SW_HIDE
        clear_fd_inherit_flags()
        kwargs["startupinfo"] = si
    else:
        env = os.environ.copy()
        env["LD_LIBRARY_PATH"] = "%s:%s" % (lt2http_dir, env.get("LD_LIBRARY_PATH", ""))
        env["GODEBUG"] = "madvdontneed=1"
        kwargs["env"] = env
        kwargs["close_fds"] = True

    wait_counter = 1
    log.debug("Checking for visible")
    while xbmc.getCondVisibility('Window.IsVisible(10140)') or xbmc.getCondVisibility('Window.IsActive(10140)'):
        if wait_counter == 1:
            log.info('Add-on settings currently opened, waiting before starting...')
        if wait_counter > 300:
            break
        time.sleep(1)
        wait_counter += 1

    log.info("lt2http: start args: %s, kw: %s" % (args, kwargs))

    if hasSubprocess:
        return subprocess.Popen(args, **kwargs)
    return False

def shutdown():
    try:
        urllib_request.urlopen(LT2HTTP_HOST + "/shutdown")
    except Exception:
        pass

def wait_for_abortRequested(proc, monitor):
    monitor.closing.wait()
    log.info("lt2http: exiting daemon")
    try:
        if proc is not None:
            proc.terminate()
    except OSError:
        pass  # Process already exited, nothing to terminate
    log.info("lt2http: daemon exited")

def lt2http_thread(monitor):
    restart_count = 0
    max_restart = 3
    last_code = 0

    try:
        monitor_abort = xbmc.Monitor()  # For Kodi >= 14
        while not monitor_abort.abortRequested():
            # If we ran out of attempts of last exit code was '-9': we do not try to start it again.
            # So if you kill the binary with '-9': it will not be restarted by this monitor.
            if restart_count > max_restart or last_code == -9:
                if monitor.reboot():
                    log.debug("lt2http: resetting attempts")
                    restart_count = 0
                    last_code = 0
                    monitor.reboot(False)
                else:
                    time.sleep(5)

                continue

            log.info("lt2http: starting")
            proc = None
            if hasSubprocess:
                proc = start_lt2http(stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
                if not proc:
                    break
            else:
                log.info("lt2http: current system is unable to run the binary")
                break

            threading.Thread(target=wait_for_abortRequested, args=[proc, monitor]).start()

            if not hasSubprocess:
                break

            if binary_platform["os"] == "windows":
                while proc.poll() is None:
                    log.info(toUtf8(proc.stdout.readline().rstrip()))
            else:
                # Kodi hangs on some Android (sigh...) systems when doing a blocking
                # read. We count on the fact that lt2http daemon flushes its log
                # output on \n, creating a pretty clean output
                import fcntl
                import select
                fd = proc.stdout.fileno()
                fl = fcntl.fcntl(fd, fcntl.F_GETFL)
                fcntl.fcntl(fd, fcntl.F_SETFL, fl | os.O_NONBLOCK)
                while proc.poll() is None:
                    try:
                        to_read, _, _ = select.select([proc.stdout], [], [])
                        for ro in to_read:
                            line = ro.readline()
                            if line == "":  # write end is closed
                                break
                            try:
                                log.info(toUtf8(line.rstrip()))
                            except TypeError:
                                pass
                    except IOError:
                        time.sleep(1)  # nothing to read, sleep

            last_code = proc.returncode
            if monitor_abort.abortRequested():
                break
            if proc.returncode == 0 or proc.returncode == -9 or proc.returncode == -1:
                continue

            if proc.returncode == 5:
                restart_count = 0
                notify(getLocalizedString(30332), time=3000)
            else:
                restart_count += 1
                notify(getLocalizedString(30100), time=3000)

            xbmc.executebuiltin("Dialog.Close(all, true)")
            system_information()
            time.sleep(5)

            if restart_count >= max_restart:
                log.debug("lt2http: no attempts left")
                notify(getLocalizedString(30110), time=3000)
                continue

    except Exception as e:
        import traceback
        map(log.error, traceback.format_exc().split("\n"))
        notify("%s: %s" % (getLocalizedString(30226), repr(e).encode('utf-8')))
        raise

    log.debug("lt2http: closing")
